---
title: "votesmart"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{votesmart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, include = FALSE}
Sys.setenv(VOTESMART_API_KEY = bonanza::secrets.get("VOTESMART_API_KEY"))
```


```{r setup}
library(votesmart)
suppressPackageStartupMessages(library(dplyr))

conflicted::conflict_prefer("filter", "dplyr") # Prefer dplyr::filter over stats::filter
```

The first step to using the `votesmart` package is to register an API key and store it in an environment variable by following [these intructions](https://github.com/decktools/votesmart#api-keys).

Let's make sure our API key is set. If it's not, the result of `Sys.getenv("VOTESMART_API_KEY")` will be `""` (i.e. a string of `nchar` 0).

```{r}
key <- Sys.getenv("VOTESMART_API_KEY")

nchar(key) > 0
```


## Get Candidates

There are currently three functions for getting information on VoteSmart candidates: `candidates_get_by_lastname`, `candidates_get_by_levenshtein`, and `candidates_get_by_office_state`.

Let's search for former US House Rep [Barney Frank](https://en.wikipedia.org/wiki/Barney_Frank) using `candidates_get_by_lastname`.

From `?candidates_get_by_lastname`, this function's defaults are:

```
candidates_get_by_lastname(
  last_names,
  election_years = lubridate::year(lubridate::today()),
  stage_ids = "",
  all = TRUE,
  verbose = TRUE
)
```

Since the default election year is the current year, we'll specify a few years in which Barney ran for office. 

```{r}
(franks <- candidates_get_by_lastname(
  last_names = "frank", 
  election_years = c(2000, 2004)
))
```

Looking at the `first_name` column, are a number of non-Barneys returned. We can next filter our results to Barney. The two rows returned correspond to the two `election_year`s we specified. 

```{r}
(barneys <- 
  franks %>% 
  filter(first_name == "Barney") %>% 
   select(
     candidate_id, first_name, last_name, 
     election_year, election_state_id, election_office
   )
)
```

Each candidate gets their own unique `candidate_id`, which we can `pull` out.

```{r}
(barney_id <- 
  barneys %>% 
  pull(candidate_id) %>% 
  unique())
```


## Get Barney's Ratings

One of the most powerful things about VoteSmart is its wealth of information about candidates' positions on issues as rated by a number of Special Interest Groups, or SIGs.

Given a `candidate_id`, we can ask for those ratings using `rating_get_candidate_ratings` to get a sense of where a candidate stands on a variety of issues, as scored by a given SIG.

```{r}
(barney_ratings <- 
  rating_get_candidate_ratings(
        candidate_ids = barney_id,
        sig_ids = "" # All SIGs
      ))

main_cols <- c("rating", "category_name", "sig_id", "timespan")
```

Some ratings are tagged with multiple cateogies. We'll filter to Barney's stance on the environment using just the first cateogry name.


```{r}
(barney_on_env <- 
  barney_ratings %>% 
  filter(category_name == "Environment") %>% 
  select(main_cols))
```

Something to be aware of is that some ratings are letter grades:

```{r}
barney_ratings %>% 
  filter(
    stringr::str_detect(rating, "[A-Z]")
  ) %>% 
  select(main_cols)
```

But using just Barney's number grades, we can get his average rating:

```{r}
barney_on_env %>% 
  summarise(
    avg_rating = mean(as.numeric(rating), na.rm = TRUE)
  )
```


Keep in mind that these are ratings given by SIGs, which could have very different base stances on issues. For example, a pro-life group might give a candidate a rating of 0 whereas a pro-choice group might give that same candidate a 100.

```{r}
barney_ratings %>% 
  filter(category_name == "Abortion") %>% 
  select(
    rating, sig_id, category_name
  )
```



## SIGs

We can get more information about these SIGs given their IDs.

```{r}
some_sigs <- 
  barney_ratings %>%
    pull(sig_id) %>%
    unique() %>%
    sample(3)

rating_get_sig(
  sig_ids = some_sigs
)
```

Or, if we don't yet have `sig_id`s, we can get a list of SIGs with the funciton `rating_get_sig_list`. That function requires a vector of `category_ids`, however, so let's first get a vector of some `category_ids`.

```{r}
(category_df <-
  rating_get_categories(
    state_ids = NA # NA for national
  ) %>% 
  distinct() %>% 
   sample_n(nrow(.)) # So we can see multiple categories in the 10 rows shown here
)

category_vec <- unique(category_df$category_id)
```

```{r}
(some_categories <- category_vec %>% sample(3))

(sigs <- 
  rating_get_sig_list(
    category_ids = some_categories,
    state_ids = NA
  ) %>% 
    select(sig_id, name, category_id, state_id)
)
```

We already have the category names corresponding to those `category_id`s in our `category_df`.

```{r}
sigs %>% 
  rename(
    sig_name = name
  ) %>% 
  left_join(
    category_df,
    by = c("state_id", "category_id")
  ) %>% 
  rename(
    category_name = name
  )
```





